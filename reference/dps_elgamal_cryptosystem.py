# -*- coding: utf-8 -*-
"""DPS_Elgamal Cryptosystem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17oiusPOiUb6O_MSWarNYwTKmx4SlBmMC
"""
# use this to check the original algo 
# this works for integer encryption and decryption
import numpy as np
import math, sympy, random

def discrete_logarithm(Zp, p, phi_n, a=None):
  dis_log, roots, order = [], [], None
  for g in Zp:
    row = []
    for x in range(1, phi_n+1):
      val = pow(int(g), int(x), p)
      row.append(val)
    for j in row:
      if j == 1:
        if a:
          order = row.index(j)+1
        if row.index(j)+1 == phi_n:
          roots.append(g)
        break
    dis_log.append(row)
  return roots[0]

def generate_Zn(n):
  Zn = []
  for i in range(1, n):
    if math.gcd(i, n) == 1:
      Zn.append(i)
  return Zn

def sgenerate_elgamal_key():
    while True:
        try:
            p = sympy.randprime(260, 1000)
            Zp, x = generate_Zn(p), random.randint(1, p-1)
            e1 = discrete_logarithm(Zp, p, len(Zp))
            break
        except Exception as e:
            print("Error", e)
            continue
    e2 = pow(e1, x, p)
    return e1,e2,p,x,Zp

def sencrypt(e1, e2, p, Zp, kkk, r):
    # r = random.choice(Zp)
    
    c1 = pow(e1, r, p)
    temp = pow(e2, r, p)
    
    xxx = (kkk*temp%p)
    return xxx, c1

def seuclideanModInverse(a, m):  
    if a == 0 :   
        return m, 0, 1
    gcd, x1, y1 = seuclideanModInverse(m%a, a)  
    x = y1 - (m//a) * x1  
    y = x1
    return gcd, x, y

def sdecrypt(xxx, secret, c, p):
    _, inv, _ = seuclideanModInverse(pow(c, secret, p), p)
    kkk = (xxx*inv)%p
    return kkk

e1,e2,p,x,Zp = sgenerate_elgamal_key()
r = 139
c2,c1 = sencrypt(e1=e1, e2=e2, p=p, Zp=Zp, r=r)
print(c1,c2)

print(sdecrypt(c2, x, c1, p))
